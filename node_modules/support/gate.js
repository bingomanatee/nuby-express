/**
 * This module allows you to track aggregate activity and
 * execute one or more callbacks when your tasks clear.
 * It is not necessary to identify individual tasks as
 * the only thing this class cares about is the quantity of tasks in the queue.
 *
 * However for future proofing, tasks are identified and optionally removed by name.
 */
var _ = require('./../../node_modules/underscore');

module.exports = function (callback, name) {
    this._tasks = [];
    this.name = name || '';
    this._start = false;
    this.debug = false;
    this.multi = false;
    this._callback = callback;
}

_.extend(module.exports.prototype, {
    start:function () {
        this._start = true;
        var self = this;
        if (this.debug) {
            console.log('GATE %s:: STARTING!!!!! with %s tasks (cb = %s)', this.name, this._tasks.length, this._callback.toString());
        }
        this._check_status();
    },

    task_start:function (task) {
        if (!task) {
            task = this._tasks.length
        }
        this._tasks.push(task);
        if (this.debug) {
            console.log('gate %s task start', this.name);
        }
    },

    task_done:function () {
        var task = this._tasks.pop();
        if (this.debug) {
            console.log('gate %s task done; %s', this.name, task);
        }

        this._check_status();
    },

    _start: false,
    _done: false,

    task_done_callback:function (start_task) {
        var my_gate = this;
        return function () {
            my_gate.task_done();
        }
        if (start_task) {
            // acknowledge that a task has been begun.
            this.task_start();
        }
    },

    _check_status:function () {
        var self = this;

        if (this._start) {

            if (this._tasks.length < 1) {
                if (this._done){
                    if (this.multi){
                        this._callback(self);
                    } else {
                        console.log('warning: gate for ' + this._callback.toString() + ' attempting to finish twice.')
                    }
                } else {
                    this._done = true;
                    if (this.debug) {
                        console.log('GATE %s:: _check_status:  !!!!! REACHED END !!!!!!', this.name);
                    }
                    this._callback(self);
                }
            } else {
                if (this.debug) {
                    console.log('GATE %s:: check status  task done; %s tasks left', this.name, this._tasks.length);
                }
            }
        } else {
            if (this.debug) {
                console.log('GATE %s:: check status, %s left: STILL NOT STARTED; ', this.name, this._tasks.length);
            }
        }
    }
})

